use anchor_lang::prelude::*;
use anchor_spl::token::{self, Token, TokenAccount, Mint};
use crate::state::Config;
use crate::constants::*;
use crate::errors::CreditError;

#[derive(Accounts)]
pub struct InitTreasury<'info> {
    #[account(
        seeds = [CONFIG_SEED],
        bump,
        constraint = config.admin == admin.key() @ CreditError::Unauthorized
    )]
    pub config: Account<'info, Config>,

    /// Treasury USDC token account (PDA)
    #[account(
        init_if_needed,
        payer = admin,
        seeds = [b"treasury_usdc"],
        bump,
        token::mint = usdc_mint,
        token::authority = treasury_authority
    )]
    pub treasury_usdc: Account<'info, TokenAccount>,

    /// Insurance fund USDC token account (PDA)
    #[account(
        init_if_needed,
        payer = admin,
        seeds = [b"insurance_usdc"],
        bump,
        token::mint = usdc_mint,
        token::authority = treasury_authority
    )]
    pub insurance_usdc: Account<'info, TokenAccount>,

    /// Treasury authority PDA
    /// CHECK: This is the PDA that has authority over treasury accounts
    #[account(
        seeds = [b"treasury_authority"],
        bump
    )]
    pub treasury_authority: UncheckedAccount<'info>,

    /// USDC mint
    #[account(
        constraint = usdc_mint.key() == config.usdc_mint @ CreditError::InvalidMint
    )]
    pub usdc_mint: Account<'info, Mint>,

    #[account(mut)]
    pub admin: Signer<'info>,

    pub token_program: Program<'info, Token>,
    pub system_program: Program<'info, System>,
}

pub fn handler(ctx: Context<InitTreasury>) -> Result<()> {
    msg!("Treasury accounts initialized");
    msg!("Treasury USDC: {}", ctx.accounts.treasury_usdc.key());
    msg!("Insurance USDC: {}", ctx.accounts.insurance_usdc.key());
    msg!("Authority: {}", ctx.accounts.treasury_authority.key());
    
    // Optionally, we could store these addresses in Config for reference
    // But they're deterministic PDAs so not strictly necessary
    
    Ok(())
}
